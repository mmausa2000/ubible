package handlers

import (
	"encoding/json"
	"log"
	"math/rand"
	"sync"
	"time"

	"github.com/gofiber/websocket/v2"
)

type Player struct {
	ID       string
	Username string
	Conn     *websocket.Conn
	Room     string
	IsReady  bool
	mu       sync.RWMutex
}

type Room struct {
	Code    string
	Host    string
	Players map[string]*Player
	State   string
	mu      sync.RWMutex
}

type Message struct {
	Type    string      `json:"type"`
	Payload interface{} `json:"payload"`
}

var (
	rooms   = make(map[string]*Room)
	players = make(map[*websocket.Conn]*Player)
	mu      sync.RWMutex
)

func HandleWebSocket(c *websocket.Conn) {
	playerID := c.Query("player_id")
	username := c.Query("username")

	if playerID == "" {
		playerID = generateID()
	}
	if username == "" {
		username = "Player" + playerID[:6]
	}

	player := &Player{
		ID:       playerID,
		Username: username,
		Conn:     c,
	}

	mu.Lock()
	players[c] = player
	mu.Unlock()

	defer func() {
		handleDisconnect(player)
		c.Close()
	}()

	send(c, "connected", map[string]interface{}{"player_id": playerID, "username": username})

	for {
		var msg Message
		if err := c.ReadJSON(&msg); err != nil {
			break
		}
		handleMessage(player, msg)
	}
}

func handleMessage(player *Player, msg Message) {
	switch msg.Type {
	case "create_room":
		handleCreateRoom(player, msg.Payload)
	case "join_room":
		handleJoinRoom(player, msg.Payload)
	case "player_ready":
		handlePlayerReady(player)
	case "find_match":
		handleFindMatch(player, msg.Payload)
	}
}

func handleCreateRoom(player *Player, payload interface{}) {
	roomCode := generateRoomCode()
	room := &Room{
		Code:    roomCode,
		Host:    player.ID,
		Players: make(map[string]*Player),
		State:   "waiting",
	}

	mu.Lock()
	rooms[roomCode] = room
	mu.Unlock()

	room.mu.Lock()
	room.Players[player.ID] = player
	room.mu.Unlock()

	player.mu.Lock()
	player.Room = roomCode
	player.mu.Unlock()

	send(player.Conn, "room_created", map[string]interface{}{"room_code": roomCode})
}

func handleJoinRoom(player *Player, payload interface{}) {
	data := parsePayload(payload)
	roomCode := getString(data, "room_code", "")

	mu.RLock()
	room, exists := rooms[roomCode]
	mu.RUnlock()

	if !exists {
		send(player.Conn, "error", map[string]interface{}{"error": "Room not found"})
		return
	}

	room.mu.Lock()
	room.Players[player.ID] = player
	room.mu.Unlock()

	player.mu.Lock()
	player.Room = roomCode
	player.mu.Unlock()

	send(player.Conn, "room_joined", map[string]interface{}{"room_code": roomCode})
	
	for _, p := range room.Players {
		if p.ID != player.ID {
			send(p.Conn, "player_joined", map[string]interface{}{"guest": player.Username})
		}
	}
}

func handlePlayerReady(player *Player) {
	player.mu.Lock()
	player.IsReady = true
	roomCode := player.Room
	player.mu.Unlock()

	mu.RLock()
	room, exists := rooms[roomCode]
	mu.RUnlock()

	if !exists {
		return
	}

	room.mu.RLock()
	allReady := len(room.Players) >= 2
	for _, p := range room.Players {
		p.mu.RLock()
		if !p.IsReady {
			allReady = false
		}
		p.mu.RUnlock()
	}
	room.mu.RUnlock()

	if allReady {
		startGame(room)
	}
}

func handleFindMatch(player *Player, payload interface{}) {
	send(player.Conn, "searching", map[string]interface{}{"players_waiting": 0})
}

func startGame(room *Room) {
	room.mu.RLock()
	defer room.mu.RUnlock()

	for _, p := range room.Players {
		send(p.Conn, "game_start", map[string]interface{}{
			"room_code": room.Code,
			"players":   len(room.Players),
		})
	}
}

func handleDisconnect(player *Player) {
	mu.Lock()
	delete(players, player.Conn)
	mu.Unlock()
}

func send(conn *websocket.Conn, msgType string, payload interface{}) {
	msg := Message{Type: msgType, Payload: payload}
	conn.WriteJSON(msg)
}

func generateRoomCode() string {
	const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, 6)
	for i := range b {
		b[i] = chars[rand.Intn(len(chars))]
	}
	return string(b)
}

func generateID() string {
	return time.Now().Format("20060102150405") + "-" + string(rune(rand.Intn(1000)))
}

func parsePayload(payload interface{}) map[string]interface{} {
	if payload == nil {
		return make(map[string]interface{})
	}
	if data, ok := payload.(map[string]interface{}); ok {
		return data
	}
	return make(map[string]interface{})
}

func getString(data map[string]interface{}, key string, defaultVal string) string {
	if val, ok := data[key]; ok {
		if str, ok := val.(string); ok {
			return str
		}
	}
	return defaultVal
}
