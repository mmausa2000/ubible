<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U Bible Quiz - Playing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 50%, #16213e 100%);
            height: 100vh;
            color: white;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .quiz-header {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .header-left {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #4caf50, #66bb6a);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: logoGlow 2s ease-in-out infinite;
        }

        @keyframes logoGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.3); }
            50% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.6); }
        }

        .app-name h1 {
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .app-name p {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-right {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 20px;
        }

        .quiz-progress {
            min-width: 300px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66bb6a);
            transition: width 0.3s ease;
            will-change: width;
        }

        .progress-text {
            text-align: center;
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .score-display {
            display: flex;
            gap: 20px;
        }

        .score-item {
            text-align: center;
            min-width: 80px;
        }

        .score-label {
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4CAF50;
            font-family: 'Courier New', monospace;
        }

        .back-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .content {
            height: calc(100vh - 60px);
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }

        .quiz-panel {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            padding: 80px 30px 30px 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100%;
            box-sizing: border-box;
        }

        /* Default scoreboard styles (hidden by default) */
        .scoreboard {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 4px 10px;
            border: 1px solid rgba(76, 175, 80, 0.2);
            display: none;
            min-width: 280px;
        }

        .scoreboard.show {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .player-score {
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .player-score.leading .player-name {
            color: #FFD700;
        }

        .player-score.leading .player-avatar {
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
            border: 2px solid #FFD700;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .player-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7rem;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .current-player .player-avatar {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b35 100%);
        }

        #opponentPlayerScore .player-avatar {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .player-name {
            font-weight: 600;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 0.8rem;
            transition: color 0.3s ease;
        }

        .player-stats {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.75rem;
            opacity: 0.9;
            font-weight: 600;
        }

        .correct-count {
            color: #4CAF50;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .score-mini {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.7rem;
        }

        .progress-bar-wrapper {
            margin-top: 4px;
        }

        .player-progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .player-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66bb6a);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .player-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-percentage {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.65rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .question-card {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        .question-container {
            width: 100%;
            min-height: 120px;
            max-height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            flex-shrink: 0;
        }

        .timer {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .score-badge {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.4);
        }

        .question-number-badge {
            background: rgba(76, 175, 80, 0.2);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #4caf50;
            font-weight: 600;
        }

        .timer.warning {
            background: rgba(255, 87, 34, 0.1);
            border-color: #FF5722;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .timer-icon {
            font-size: 1.5rem;
        }

        .timer-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            min-width: 40px;
            text-align: right;
        }

        .question-text {
            font-size: 1.4rem;
            line-height: 1.5;
            text-align: center;
            color: #fff;
            font-weight: 500;
            max-width: 850px;
            margin: 0;
            overflow-y: auto;
            max-height: 100%;
            padding: 10px;
        }

        .options-container {
            flex: 1;
            max-height: 50vh;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            padding: 0 20px;
        }

        .options-grid {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 18px;
            flex-shrink: 0;
        }

        .option-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 18px;
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
            padding: 18px 24px;
            width: 100%;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(6px);
        }

        .option-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(102, 187, 106, 0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .option-btn:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.15);
            border-color: #fff;
            transform: scale(1.02);
        }

        .option-btn:hover:not(.disabled)::before {
            opacity: 1;
        }

        .option-btn:active:not(.disabled) {
            transform: translateY(-1px);
        }

        .option-btn.correct {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4caf50;
            animation: correctPulse 0.6s ease;
        }

        .option-btn.incorrect {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
            animation: wrongShake 0.5s ease;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .option-btn.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .footer {
            background: rgba(255, 255, 255, 0.05);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 40px;
            min-height: 50px;
        }

        .footer-info {
            display: flex;
            gap: 30px;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }

        .info-icon {
            color: #4caf50;
            font-size: 1rem;
        }

        .info-value {
            color: white;
            font-weight: 600;
        }

        .footer-actions {
            display: flex;
            gap: 10px;
        }

        .footer-link {
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .footer-link:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .results-modal.show {
            display: flex;
        }

        .results-content {
            background: linear-gradient(135deg, #2a3050 0%, #3a4570 100%);
            border-radius: 24px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            border: 2px solid rgba(76, 175, 80, 0.3);
            text-align: center;
        }

        .results-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .results-subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 16px;
        }

        .result-stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .result-stat-label {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .results-btns {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn:hover {
            transform: translateY(-3px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4CAF50, #66bb6a);
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336, #e53935);
            color: white;
        }

        .confirm-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .confirm-modal.show {
            display: flex;
        }

        .confirm-content {
            background: linear-gradient(135deg, #2a3050 0%, #3a4570 100%);
            border-radius: 24px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            border: 2px solid rgba(255, 152, 0, 0.3);
            text-align: center;
        }

        .confirm-icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .confirm-title {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .confirm-message {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .confirm-buttons {
            display: flex;
            gap: 15px;
        }

        /* === Integrate Scoreboard into Header === */
        .quiz-header .scoreboard {
            flex-direction: row !important;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            min-width: unset;
            backdrop-filter: none !important;
            box-shadow: none !important;
        }

        .quiz-header .scoreboard.show { 
            display: flex !important; 
        }

        .quiz-header .player-score {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 6px 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .quiz-header .player-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 0;
        }

        .quiz-header .player-info {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quiz-header .player-avatar {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quiz-header .player-name {
            font-size: 0.8rem;
            font-weight: 600;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .quiz-header .player-stats {
            font-size: 0.7rem;
            gap: 4px;
            opacity: 0.85;
        }

        .quiz-header .progress-bar-wrapper {
            display: none;
        }

        .quiz-header .player-score.leading {
            background: rgba(76, 175, 80, 0.15);
            border-color: rgba(76, 175, 80, 0.4);
        }

        /* Countdown Overlay */
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(8px) saturate(1.05);
            -webkit-backdrop-filter: blur(8px) saturate(1.05);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }

        .countdown-overlay.show {
            display: flex;
            animation: fadeInOverlay 200ms ease-out;
        }

        @keyframes fadeInOverlay {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .countdown-content {
            text-align: center;
            transform: translateY(-10px);
            animation: slideUpIn 300ms ease-out;
        }

        @keyframes slideUpIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .countdown-title {
            font-size: 1.2rem;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.85);
            margin-bottom: 10px;
        }

        .countdown-number {
            font-weight: 900;
            font-size: 7rem;
            line-height: 1;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #4CAF50, #66bb6a);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 8px 30px rgba(76,175,80,0.35);
            animation: popScale 350ms ease-out;
        }

        .countdown-number.pop {
            animation: popScale 350ms ease-out;
        }

        @keyframes popScale {
            0% { transform: scale(0.6); opacity: 0; }
            60% { transform: scale(1.08); opacity: 1; }
            100% { transform: scale(1); }
        }

        .countdown-number.go {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 0 8px 40px rgba(255, 107, 107, 0.5);
            font-size: 6rem;
            animation: popScale 350ms ease-out;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 20px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2a3050 0%, #3a4570 100%);
            border-radius: 24px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            border: 2px solid rgba(76, 175, 80, 0.3);
        }

        /* Responsive layout for tablets and smaller screens */
        @media (max-width: 768px) {
            .app-container {
                grid-template-rows: 70px 1fr 70px;
                width: 100%;
                height: 100vh;
                max-height: none;
                border-radius: 0;
            }

            .quiz-header {
                padding: 0 20px;
            }

            .header-right {
                flex-direction: column;
                gap: 10px;
                align-items: flex-end;
            }

            .quiz-progress {
                min-width: 200px;
            }

            .score-display {
                gap: 10px;
            }

            .content {
                padding: 0;
            }

            .quiz-panel {
                padding: 40px 20px;
            }

            .question-text {
                font-size: 1.1rem;
                padding: 15px;
            }

            .option-btn {
                font-size: 1rem;
                padding: 14px;
            }
        }

        /* Responsive layout for mobile phones */
        @media (max-width: 480px) {
            .quiz-panel {
                padding: 30px 15px;
            }

            .question-text {
                font-size: 1rem;
                line-height: 1.4;
            }

            .option-btn {
                font-size: 0.95rem;
                padding: 12px;
            }

            .footer {
                padding: 0 20px;
            }

            .footer-info {
                display: none;
            }

            .countdown-number {
                font-size: 5rem;
            }

            .countdown-number.go {
                font-size: 4.5rem;
            }
        }
    </style>
</head>
<body>
        <div class="quiz-header">
            <div class="header-left">
                <div class="logo" onclick="location.href='/'" style="cursor: pointer;" title="Go to Home">üìñ</div>
                <div class="app-name" onclick="location.href='/'" style="cursor: pointer;" title="Go to Home">
                    <h1>U Bible</h1>
                    <p>Playing Quiz</p>
                </div>
                <div class="question-number-badge">
                    <span id="progressText">Question 1 of 20</span>
                </div>
            </div>
            
            <div class="header-center">
                <div class="timer" id="timer">
                    <span class="timer-icon">‚è±Ô∏è</span>
                    <span class="timer-value" id="timerValue">30</span>
                    <span>s</span>
                </div>
                <div class="scoreboard" id="scoreboard" style="display:none;">
                    <div class="player-score current-player" id="currentPlayerScore">
                        <div class="player-header">
                            <div class="player-info">
                                <div class="player-avatar" id="currentPlayerAvatar">Y</div>
                                <div class="player-name" id="currentPlayerName">You</div>
                            </div>
                            <div class="player-stats">
                                <span class="correct-count" id="currentCorrectCount">0</span>
                                <span>/</span>
                                <span id="currentTotalQuestions">20</span>
                                <span class="score-mini">(<span id="currentPlayerScoreValue">0</span> pts)</span>
                            </div>
                        </div>
                        <div class="progress-bar-wrapper">
                            <div class="player-progress-bar">
                                <div class="player-progress-fill" id="currentPlayerProgress" style="width: 0%">
                                    <span class="progress-percentage" id="currentProgressPercent">0%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="player-score" id="opponentPlayerScore">
                        <div class="player-header">
                            <div class="player-info">
                                <div class="player-avatar" id="opponentPlayerAvatar">O</div>
                                <div class="player-name" id="opponentPlayerName">Opponent</div>
                            </div>
                            <div class="player-stats">
                                <span class="correct-count" id="opponentCorrectCount">0</span>
                                <span>/</span>
                                <span id="opponentTotalQuestions">20</span>
                                <span class="score-mini">(<span id="opponentPlayerScoreValue">0</span> pts)</span>
                            </div>
                        </div>
                        <div class="progress-bar-wrapper">
                            <div class="player-progress-bar">
                                <div class="player-progress-fill" id="opponentPlayerProgress" style="width: 0%">
                                    <span class="progress-percentage" id="opponentProgressPercent">0%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="header-right">
                <div class="stat-item score-badge">
                    <span>üéØ</span>
                    <span id="score">0/20</span>
                </div>

                <div class="score-display">
                    <div class="score-item">
                        <div class="score-label">Score</div>
                        <div class="score-value" id="currentScore">0</div>
                    </div>
                    <div class="score-item">
                        <div class="score-label">Streak</div>
                        <div class="score-value" id="streakDisplay">0üî•</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="quiz-panel">
                <div class="question-card">
                    <div class="question-container">
                        <div class="question-text" id="questionText">Loading questions...</div>
                    </div>

                    <div class="options-grid" id="optionsGrid"></div>
                </div>
            </div>
        </div>

        <div class="footer">
            <div class="footer-info">
                <div class="info-item">
                    <span class="info-icon">‚è±Ô∏è</span>
                    <span>Time: <span class="info-value" id="footerTimeLimit">20s</span></span>
                </div>
                <div class="info-item">
                    <span class="info-icon">üìù</span>
                    <span>Questions: <span class="info-value" id="footerQuestionCount">20</span></span>
                </div>
                <div class="info-item">
                    <span class="info-icon">üéØ</span>
                    <span>Accuracy: <span class="info-value" id="footerAccuracy">0%</span></span>
                </div>
            </div>
            
            <div class="footer-actions">
                <a href="#" class="footer-link" onclick="confirmExit(event); return false;">Exit Quiz</a>
                <a href="/settings.html" class="footer-link">Settings</a>
                <a href="#" class="footer-link" onclick="openAboutModal(); return false;">About</a>
            </div>
        </div>
    </div>

    <div class="results-modal" id="resultsModal">
        <div class="results-content">
            <div class="results-title">üéâ</div>
            <div class="results-subtitle">Quiz Complete!</div>

            <div class="results-stats">
                <div class="result-stat">
                    <div class="result-stat-value" id="finalScore">0</div>
                    <div class="result-stat-label">Final Score</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value" id="finalAccuracy">0%</div>
                    <div class="result-stat-label">Accuracy</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value" id="correctCount">0</div>
                    <div class="result-stat-label">Correct</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value" id="bestStreak">0</div>
                    <div class="result-stat-label">Best Streak</div>
                </div>
            </div>

            <div class="results-btns">
                <button class="btn btn-secondary" onclick="location.href='/settings.html'">Settings</button>
                <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
                <button class="btn btn-primary" onclick="location.href='/'">Home</button>
            </div>
        </div>
    </div>

    <div class="confirm-modal" id="confirmModal">
        <div class="confirm-content">
            <div class="confirm-icon">‚ö†Ô∏è</div>
            <h2 class="confirm-title">Exit Quiz?</h2>
            <p class="confirm-message">Your progress will be lost. Where would you like to go?</p>
            <div style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 12px; margin: 20px 0; border: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.2rem;">
                    <span>‚è±Ô∏è</span>
                    <span id="confirmTimerValue" style="font-weight: bold; color: #4CAF50; font-size: 1.5rem;">--</span>
                    <span>seconds remaining</span>
                </div>
            </div>
            <div class="confirm-buttons">
                <button class="btn btn-secondary" onclick="exitToSettings()">Settings</button>
                <button class="btn btn-primary" onclick="closeConfirmModal()">Continue Quiz</button>
                <button class="btn btn-danger" onclick="exitToHome()">Home</button>
            </div>
        </div>
    </div>

    <div class="confirm-modal" id="opponentQuitModal">
        <div class="confirm-content">
            <div class="confirm-icon">üèÜ</div>
            <h2 class="confirm-title">You Win!</h2>
            <p class="confirm-message">Your opponent has left the match. You win by default!</p>
            <div style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid rgba(76, 175, 80, 0.3);">
                <div style="font-size: 3rem; margin-bottom: 10px;">üëë</div>
                <div style="font-size: 1.2rem; font-weight: bold; color: #4CAF50;">Victory!</div>
            </div>
            <div class="confirm-buttons">
                <button class="btn btn-secondary" onclick="location.href='/settings.html'">Settings</button>
                <button class="btn btn-primary" onclick="location.href='/'">Home</button>
            </div>
        </div>

    <!-- Countdown Overlay -->
    <div class="countdown-overlay" id="countdownOverlay">
        <div class="countdown-content">
            <div class="countdown-title">üéØ Get Ready!</div>
            <div class="countdown-number" id="countdownNumber">3</div>
        </div>
    </div>

    <!-- About Modal -->
    <div class="modal-overlay" id="aboutModal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <h2 style="margin-bottom: 20px; color: #4caf50;">üìñ About This App</h2>

            <div style="line-height: 1.8; color: rgba(255, 255, 255, 0.9); margin-bottom: 25px;">
                <p style="margin-bottom: 15px;">
                    This app was created by <strong style="color: #4caf50;">Apostle Maliyabwana</strong>, the current Overseer and Apostle of the Ukweli Church of Christ, also known as Ukweli Ministries. Born Meshak Mausa, Maliyabwana began programming in 2012, inspired by the story of Mark Zuckerberg, who built his first app at the age of 12.
                </p>

                <p style="margin-bottom: 15px;">
                    Motivated by that story, he immersed himself in computer science and discovered Codeacademy (now known as Codecademy). He spent countless hours‚Äîsometimes up to 24 hours a day without sleep‚Äîon his father's computer learning web design and programming. This deep dedication continued until the age of 13, when his creative passions began to expand in new directions.
                </p>

                <p style="margin-bottom: 15px;">
                    During that period, he taught himself Photoshop, believing that building clean and professional websites required strong design skills. This opened the door to photo editing, and a few years later, to music production. Eventually, he founded the <strong>NDP Entertainment Label</strong>, operating under the alias <em>Six Sons</em>, where he produced music and designed cover art for his friends.
                </p>

                <p style="margin-bottom: 15px;">
                    His love for technology and creativity later led him into the field of sound engineering, merging his artistic expression with technical skill.
                </p>

                <p style="margin-bottom: 25px;">
                    Born and raised in Tanzania (TZ), Maliyabwana moved to the United States in 2010 at the age of 10, carrying with him a deep passion for knowledge, innovation, and purpose‚Äîvalues that continue to shape both his ministry and his creative work today.
                </p>
            </div>

            <div style="background: rgba(76, 175, 80, 0.1); border: 2px solid rgba(76, 175, 80, 0.3); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px; color: #4caf50; font-size: 1.2rem;">üíö Support the Project</h3>
                <p style="margin-bottom: 15px; line-height: 1.6; color: rgba(255, 255, 255, 0.9);">
                    This app is still in its improvement stage, and your support can help it grow. If you'd like to contribute, you can donate via:
                </p>
                <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                    <div style="background: rgba(0, 0, 0, 0.2); padding: 12px 15px; border-radius: 10px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.3rem;">üíµ</span>
                        <span style="color: rgba(255, 255, 255, 0.7);">Cash App:</span>
                        <strong style="color: #4caf50;">$ukweliministries</strong>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.2); padding: 12px 15px; border-radius: 10px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.3rem;">üí≥</span>
                        <span style="color: rgba(255, 255, 255, 0.7);">PayPal:</span>
                        <strong style="color: #0070ba;">@ukweliministries</strong>
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="closeAboutModal()" style="width: 100%; padding: 12px; font-size: 1rem;">
                Close
            </button>
        </div>
    </div>

    <script>
        // Suppress browser extension errors
        window.addEventListener('error', (e) => {
            if (e.message && e.message.includes('message channel closed')) {
                e.preventDefault();
                e.stopPropagation();
                return true;
            }
        });

        window.addEventListener('unhandledrejection', (e) => {
            if (e.reason && e.reason.message && e.reason.message.includes('message channel closed')) {
                e.preventDefault();
                e.stopPropagation();
                return true;
            }
        });

        function loadQuizSettings() {
            try {
                const multiplayerData = localStorage.getItem('multiplayerGame');
                if (multiplayerData) {
                    const gameData = JSON.parse(multiplayerData);
                    if (gameData.isMultiplayer && gameData.timeLimit) {
                        return {
                            time: gameData.timeLimit,
                            questions: gameData.questions.length
                        };
                    }
                }
            } catch (e) {
                console.error('Error loading multiplayer settings:', e);
            }

            try {
                const saved = localStorage.getItem('quizSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    return {
                        time: Number(settings.timeLimit) || 20,
                        questions: Number(settings.questionCount) || 20
                    };
                }
            } catch (e) {
                console.error('Error loading quiz settings:', e);
            }
            
            return { time: 20, questions: 20 };
        }

        const currentSettings = loadQuizSettings();

        const QuizState = {
            questions: [],
            currentQuestionIndex: 0,
            score: 0,
            currentStreak: 0,
            bestStreakValue: 0,
            correctAnswers: 0,
            timeRemaining: currentSettings.time,
            timerInterval: null,
            answerHistory: [], // Track: { questionIndex, isCorrect, timeTaken, timeLimit, isSlow }

            reset() {
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.currentStreak = 0;
                this.bestStreakValue = 0;
                this.correctAnswers = 0;
                this.answerHistory = [];
                this.clearTimer();
            },

            clearTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            },

            recordAnswer(questionIndex, isCorrect, timeTaken, timeLimit) {
                const slowThreshold = timeLimit * 0.75; // 75% of time limit
                const isSlow = timeTaken >= slowThreshold;

                this.answerHistory.push({
                    questionIndex,
                    isCorrect,
                    timeTaken,
                    timeLimit,
                    isSlow
                });

                console.log(`üìä Answer recorded: Q${questionIndex+1} - ${isCorrect ? 'Correct' : 'Wrong'} - ${timeTaken}s/${timeLimit}s ${isSlow ? '(SLOW)' : ''}`);
            }
        };

        const MultiplayerState = {
            opponentAnswered: false,
            currentPlayerAnswered: false,
            opponentScore: 0,
            opponentCorrectAnswers: 0,
            opponentName: 'Opponent',
            ws: null,
            roomCode: null,
            totalQuestions: 20,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 1000, // Start with 1 second
            lastSeq: 0, // Track last received sequence number for ordering
            pendingMessages: [], // Buffer for out-of-order messages
            heartbeatInterval: null,
            lastPongTime: Date.now(),

            reset() {
                this.opponentAnswered = false;
                this.currentPlayerAnswered = false;
            },

            bothAnswered() {
                return this.opponentAnswered && this.currentPlayerAnswered;
            },

            sendScoreUpdate() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const game = JSON.parse(localStorage.getItem('multiplayerGame') || '{}');
                    const roomCode = this.roomCode || game.room_code || game.roomCode || null;

                    // Modern payload format
                    this.ws.send(JSON.stringify({
                        type: 'score_update',
                        payload: {
                            room_code: roomCode,
                            score: QuizState.score,
                            correct_answers: QuizState.correctAnswers
                        }
                    }));

                    // Legacy fallback (camelCase, top-level)
                    this.ws.send(JSON.stringify({
                        type: 'score_update',
                        score: QuizState.score,
                        correctAnswers: QuizState.correctAnswers,
                        roomCode: roomCode
                    }));
                }
            },

            updateOpponentScore(score, correctAnswers) {
                this.opponentScore = score;
                this.opponentCorrectAnswers = correctAnswers || 0;
                this.updateScoreboard();
            },

            updateScoreboard() {
                const currentScoreEl = document.getElementById('currentPlayerScoreValue');
                const currentCorrectEl = document.getElementById('currentCorrectCount');
                const currentProgressBar = document.getElementById('currentPlayerProgress');
                const currentProgressPercent = document.getElementById('currentProgressPercent');
                const currentPlayerCard = document.getElementById('currentPlayerScore');
                
                if (currentScoreEl) currentScoreEl.textContent = QuizState.score;
                if (currentCorrectEl) currentCorrectEl.textContent = QuizState.correctAnswers;
                if (currentProgressBar) {
                    const percentage = (QuizState.correctAnswers / this.totalQuestions) * 100;
                    currentProgressBar.style.width = `${percentage}%`;
                    if (currentProgressPercent) {
                        currentProgressPercent.textContent = `${Math.round(percentage)}%`;
                    }
                }

                const opponentScoreEl = document.getElementById('opponentPlayerScoreValue');
                const opponentCorrectEl = document.getElementById('opponentCorrectCount');
                const opponentProgressBar = document.getElementById('opponentPlayerProgress');
                const opponentProgressPercent = document.getElementById('opponentProgressPercent');
                const opponentPlayerCard = document.getElementById('opponentPlayerScore');

                if (opponentScoreEl) opponentScoreEl.textContent = this.opponentScore;
                if (opponentCorrectEl) opponentCorrectEl.textContent = this.opponentCorrectAnswers;
                if (opponentProgressBar) {
                    const percentage = (this.opponentCorrectAnswers / this.totalQuestions) * 100;
                    opponentProgressBar.style.width = `${percentage}%`;
                    if (opponentProgressPercent) {
                        opponentProgressPercent.textContent = `${Math.round(percentage)}%`;
                    }
                }

                const currentTotal = document.getElementById('currentTotalQuestions');
                const opponentTotal = document.getElementById('opponentTotalQuestions');
                if (currentTotal) currentTotal.textContent = this.totalQuestions;
                if (opponentTotal) opponentTotal.textContent = this.totalQuestions;

                if (QuizState.correctAnswers > this.opponentCorrectAnswers) {
                    currentPlayerCard.classList.add('leading');
                    opponentPlayerCard.classList.remove('leading');
                } else if (this.opponentCorrectAnswers > QuizState.correctAnswers) {
                    opponentPlayerCard.classList.add('leading');
                    currentPlayerCard.classList.remove('leading');
                } else {
                    currentPlayerCard.classList.remove('leading');
                    opponentPlayerCard.classList.remove('leading');
                }
            },

            // Process message with sequence number ordering
            processMessage(msg) {
                // If message has no sequence number, process immediately (legacy support)
                if (!msg.seq) {
                    return msg;
                }

                // Check if message is in order
                if (msg.seq <= this.lastSeq) {
                    console.warn(`[Quiz] Dropping stale/duplicate message: seq=${msg.seq}, lastSeq=${this.lastSeq}, type=${msg.type}`);
                    return null; // Discard stale/duplicate message
                }

                // If message is next in sequence, process it
                if (msg.seq === this.lastSeq + 1) {
                    this.lastSeq = msg.seq;
                    console.log(`[Quiz] Processing message in order: seq=${msg.seq}, type=${msg.type}`);

                    // Check if any pending messages can now be processed
                    this.processPendingMessages();
                    return msg;
                }

                // Message arrived out of order - buffer it
                console.log(`[Quiz] Buffering out-of-order message: seq=${msg.seq}, expected=${this.lastSeq + 1}, type=${msg.type}`);
                this.pendingMessages.push(msg);
                this.pendingMessages.sort((a, b) => a.seq - b.seq);

                // Limit pending buffer size to prevent memory issues
                if (this.pendingMessages.length > 20) {
                    console.warn('[Quiz] Pending message buffer full, processing oldest messages');
                    this.processPendingMessages();
                }

                return null; // Don't process yet
            },

            processPendingMessages() {
                let processed = 0;
                while (this.pendingMessages.length > 0) {
                    const nextMsg = this.pendingMessages[0];
                    if (nextMsg.seq === this.lastSeq + 1) {
                        this.pendingMessages.shift();
                        this.lastSeq = nextMsg.seq;
                        console.log(`[Quiz] Processing buffered message: seq=${nextMsg.seq}, type=${nextMsg.type}`);

                        // Re-dispatch the message for processing
                        this.handleOrderedMessage(nextMsg);
                        processed++;
                    } else {
                        break; // Wait for missing message
                    }
                }
                if (processed > 0) {
                    console.log(`[Quiz] Processed ${processed} buffered messages`);
                }
            },

            handleOrderedMessage(msg) {
                // This will be called from the main message handler
                // The message has already been validated for ordering
                const event = { data: JSON.stringify(msg) };
                // Trigger normal message processing
                if (this.ws && this.ws.onmessage) {
                    // Create a synthetic event that bypasses ordering check
                    const syntheticEvent = { data: JSON.stringify({ ...msg, _skipOrdering: true }) };
                    setTimeout(() => {
                        if (this.ws && this.ws.onmessage) {
                            this.ws.onmessage(syntheticEvent);
                        }
                    }, 0);
                }
            },

            startHeartbeat() {
                this.stopHeartbeat();
                this.lastPongTime = Date.now();

                this.heartbeatInterval = setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        // Send ping
                        this.ws.send(JSON.stringify({ type: 'ping' }));

                        // Check if we received pong recently
                        const timeSinceLastPong = Date.now() - this.lastPongTime;
                        if (timeSinceLastPong > 30000) { // 30 seconds without pong
                            console.warn('[Quiz] No pong received for 30s, connection may be dead');
                            this.ws.close();
                        }
                    }
                }, 20000); // Send ping every 20 seconds
            },

            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            },

            attemptReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    console.error('[Quiz] Max reconnection attempts reached');
                    alert('Connection lost. Please return to the main menu and try again.');
                    return;
                }

                this.reconnectAttempts++;
                const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff

                console.log(`[Quiz] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                setTimeout(() => {
                    location.reload();
                }, delay);
            }
        };

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        async function loadQuestions() {
            try {
                const multiplayerData = localStorage.getItem('multiplayerGame');
                if (multiplayerData) {
                    try {
                        const gameData = JSON.parse(multiplayerData);
                        // Only use pre-loaded questions if they actually exist
                        if (gameData.isMultiplayer && gameData.questions && gameData.questions.length > 0) {
                            console.log('üì• Using pre-loaded multiplayer questions:', gameData.questions.length);
                            QuizState.questions = gameData.questions;
                            return;
                        } else if (gameData.isMultiplayer) {
                            console.log('üåê Multiplayer game - will fetch questions from API');
                        }
                    } catch (e) {
                        console.error('Error parsing multiplayer game data:', e);
                    }
                }
                
                // Load ALL verses first (backend doesn't support multi-theme filtering)
                let url = `/api/verses?limit=100`; // Request more than needed
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const data = await response.json();
                console.log('API Response:', data); // Debug logging
                
                if (!data.success || !data.verses) throw new Error('Failed to load questions');

                let questions = data.verses;
                console.log('Total verses loaded:', questions.length); // Debug logging
                
                // Check for theme from URL parameter first
                const urlParams = new URLSearchParams(window.location.search);
                const urlThemeId = urlParams.get('theme');

                // Client-side filtering by selected themes (now using theme IDs)
                let themes = [];
                if (urlThemeId) {
                    // Use theme from URL
                    themes = [parseInt(urlThemeId)];
                } else {
                    // Use themes from localStorage (from settings page)
                    themes = JSON.parse(localStorage.getItem('selectedThemes') || '[]');
                }
                console.log('Selected theme IDs:', themes); // Debug logging

                console.log('Total verses loaded:', data.verses.length);
                console.log('First verse:', data.verses[0]);
                console.log('First verse theme (normalized):', (data.verses[0]?.theme_name ?? data.verses[0]?.themeName ?? data.verses[0]?.ThemeName ?? 'NO THEME'));
                console.log('All verse theme IDs:', data.verses.map(v => v.theme_id));
                console.log('All verse theme names:', data.verses.map(v => v.theme_name ?? v.themeName ?? v.ThemeName));
                console.log('Selected theme IDs:', themes);

                if (themes.length > 0 && Array.isArray(themes)) {
                    // Filter by theme ID (themes is now an array of IDs)
                    questions = questions.filter(q => {
                        if (!q.theme_id) return false;
                        // Match theme IDs
                        const matched = themes.includes(q.theme_id);
                        if (matched) {
                            const themeName = q.theme_name ?? q.themeName ?? q.ThemeName ?? '';
                            console.log('Question matched theme ID:', q.theme_id, themeName);
                        }
                        return matched;
                    });
                }

                console.log('Filtered verses:', questions.length); // Debug logging
                console.log('Final questions array:', questions);

                if (questions.length === 0) {
                    console.error('‚ùå No verses after filtering!');
                    console.error('Debug info:', {
                        selectedThemes: themes,
                        totalQuestionsFromAPI: data.verses.length,
                        availableThemeIds: [...new Set(data.verses.map(v => v.theme_id))],
                        localStorage: localStorage.getItem('selectedThemes')
                    });
                    throw new Error('No questions match your selected themes. Please go to Settings and re-select your themes.');
                }

                // Smart Repetition System: Always deliver requested count
                const requestedQuestions = currentSettings.questions;
                const availableQuestions = questions.length;

                if (availableQuestions >= requestedQuestions) {
                    // Have enough unique questions
                    QuizState.questions = questions.slice(0, requestedQuestions);
                    console.log(`‚úÖ Questions: Using ${requestedQuestions} unique questions`);
                } else {
                    // Need to repeat questions to reach requested count
                    const gap = requestedQuestions - availableQuestions;
                    console.log(`üîÑ Smart Repetition: Need ${gap} more questions (have ${availableQuestions}, want ${requestedQuestions})`);

                    // Start with all unique questions
                    QuizState.questions = [...questions];

                    // Build repetition pool (will be filled as quiz progresses)
                    // For now, repeat random questions to fill the gap
                    for (let i = 0; i < gap; i++) {
                        const randomIndex = Math.floor(Math.random() * availableQuestions);
                        QuizState.questions.push(questions[randomIndex]);
                    }

                    // Shuffle to mix repeated questions throughout
                    QuizState.questions = shuffleArray(QuizState.questions);

                    console.log(`üìä Final: ${QuizState.questions.length} questions (${availableQuestions} unique + ${gap} repeated)`);
                }
                
            } catch (error) {
                console.error('Error loading questions:', error);
                throw error;
            }
        }

        function showCountdown(seconds, callback) {
            const totalSeconds = seconds;
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                transition: background 0.3s ease;
            `;

            const countText = document.createElement('div');
            countText.style.cssText = `
                font-size: 10rem;
                font-weight: 900;
                color: #4caf50;
                animation: pulse 1s ease;
            `;
            countText.textContent = seconds;
            overlay.appendChild(countText);
            document.body.appendChild(overlay);

            const interval = setInterval(() => {
                seconds--;

                // Calculate opacity based on remaining seconds (fade from 0.9 to 0)
                const opacity = (seconds / totalSeconds) * 0.9;
                overlay.style.background = `rgba(0,0,0,${opacity})`;

                if (seconds > 0) {
                    countText.textContent = seconds;
                } else {
                    clearInterval(interval);
                    overlay.remove();
                    callback();
                }
            }, 1000);
        }

        async function startQuiz() {
            // Set a static loading message (no animation to avoid race conditions)
            const questionText = document.getElementById('questionText');
            if (questionText) {
                questionText.textContent = 'Loading questions...';
            }

            showCountdown(3, async () => {
                try {
                    document.getElementById('timerValue').textContent = currentSettings.time;
                    document.getElementById('footerTimeLimit').textContent = currentSettings.time + 's';
                    document.getElementById('footerQuestionCount').textContent = currentSettings.questions;

                    await loadQuestions();

                    const gameData = localStorage.getItem('multiplayerGame');
                    if (gameData && JSON.parse(gameData).isMultiplayer) {
                        MultiplayerState.totalQuestions = QuizState.questions.length;
                        MultiplayerState.updateScoreboard();
                    }

                    // Clear loading message and display first question
                    const questionTextEl = document.getElementById('questionText');
                    if (questionTextEl) {
                        questionTextEl.textContent = ''; // Clear loading message
                    }

                    if (QuizState.questions.length > 0) {
                        displayQuestion();
                    } else {
                        document.getElementById('questionText').textContent =
                            'No questions available. Please add verses in your themes.';
                    }
                } catch (error) {
                    console.error('Failed to initialize quiz:', error);
                    document.getElementById('questionText').textContent = 'Failed to load quiz. Please try again.';
                }
            });
        }

        function displayQuestion() {
            if (QuizState.currentQuestionIndex >= QuizState.questions.length) {
                showResults();
                return;
            }

            const question = QuizState.questions[QuizState.currentQuestionIndex];

            const questionTextEl = document.getElementById('questionText');
            questionTextEl.textContent = question.text;

            // Update question number badge
            document.getElementById('progressText').textContent =
                `Question ${QuizState.currentQuestionIndex + 1} of ${QuizState.questions.length}`;

            const optionsContainer = document.getElementById('optionsGrid');
            optionsContainer.innerHTML = '';

            question.options.forEach((option) => {
                const button = document.createElement('button');
                button.className = 'option-btn';
                button.textContent = option;
                button.onclick = () => selectAnswer(option, question.correct_answer);
                optionsContainer.appendChild(button);
            });

            startTimer();
        }

        function resizeTextToFit(textElement, container) {
            const maxFontSize = 1.6; // rem
            const minFontSize = 0.9; // rem
            let fontSize = maxFontSize;

            // Convert rem to px (assuming 16px base)
            const remToPx = 16;

            textElement.style.fontSize = fontSize + 'rem';

            // Get container dimensions
            const containerHeight = container.clientHeight;
            const containerPadding = parseFloat(getComputedStyle(container).paddingTop) +
                                     parseFloat(getComputedStyle(container).paddingBottom);
            const availableHeight = containerHeight - containerPadding;

            // Reduce font size until text fits
            while (textElement.scrollHeight > availableHeight && fontSize > minFontSize) {
                fontSize -= 0.05;
                textElement.style.fontSize = fontSize + 'rem';
            }
        }

        function startTimer() {
            QuizState.timeRemaining = currentSettings.time;
            updateTimerDisplay();
            
            QuizState.clearTimer();
            QuizState.timerInterval = setInterval(() => {
                QuizState.timeRemaining--;
                updateTimerDisplay();
                
                if (QuizState.timeRemaining <= 0) {
                    QuizState.clearTimer();
                    
                    if (!MultiplayerState.currentPlayerAnswered) {
                        selectAnswer(null, QuizState.questions[QuizState.currentQuestionIndex].correct_answer);
                    }
                    
                    setTimeout(() => {
                        MultiplayerState.reset();
                        QuizState.currentQuestionIndex++;
                        displayQuestion();
                    }, 1000);
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const timerEl = document.getElementById('timerValue');
            const timerContainer = document.getElementById('timer');
            
            if (timerEl) {
                timerEl.textContent = QuizState.timeRemaining;
                
                if (QuizState.timeRemaining <= 5) {
                    timerContainer.classList.add('warning');
                } else {
                    timerContainer.classList.remove('warning');
                }
            }
        }

        function selectAnswer(selectedAnswer, correctAnswer) {
            MultiplayerState.currentPlayerAnswered = true;

            // CRITICAL: Stop the timer immediately to prevent race conditions
            QuizState.clearTimer();

            const isCorrect = selectedAnswer === correctAnswer;
            const timeTaken = currentSettings.time - QuizState.timeRemaining;
            const timeBonus = Math.max(0, QuizState.timeRemaining * 10);

            // Calculate points earned for THIS question only
            const pointsEarned = isCorrect ? (100 + timeBonus) : 0;

            // Record answer metadata for smart repetition
            QuizState.recordAnswer(QuizState.currentQuestionIndex, isCorrect, timeTaken, currentSettings.time);

            if (isCorrect) {
                QuizState.correctAnswers++;
                QuizState.currentStreak++;
                QuizState.score += pointsEarned;

                if (QuizState.currentStreak > QuizState.bestStreakValue) {
                    QuizState.bestStreakValue = QuizState.currentStreak;
                }
            } else {
                QuizState.currentStreak = 0;
            }

            updateScoreDisplay();
            updateStreakDisplay();

            const buttons = document.querySelectorAll('.option-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.classList.add('disabled');
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                } else if (btn.textContent === selectedAnswer && !isCorrect) {
                    btn.classList.add('incorrect');
                }
            });

            const gameData = localStorage.getItem('multiplayerGame');
            const isMultiplayer = gameData && JSON.parse(gameData).isMultiplayer;

            if (isMultiplayer) {
                if (MultiplayerState.ws && MultiplayerState.ws.readyState === WebSocket.OPEN) {
                    const game = JSON.parse(localStorage.getItem('multiplayerGame') || '{}');
                    const roomCode = MultiplayerState.roomCode || game.room_code || game.roomCode || null;

                    // Validate room code before submitting
                    if (!roomCode) {
                        console.error('[Quiz] ‚ùå Cannot submit answer: No room code available');
                        alert('Connection error. Please return to the main menu.');
                        return;
                    }

                    // Send single submit_answer event with points for THIS question only
                    console.log('[Quiz] Submitting answer:', {roomCode, questionIndex: QuizState.currentQuestionIndex, score: pointsEarned});
                    MultiplayerState.ws.send(JSON.stringify({
                        type: 'submit_answer',
                        payload: {
                            room_code: roomCode,
                            question_index: QuizState.currentQuestionIndex,
                            is_correct: isCorrect,
                            score: pointsEarned,  // Send points for THIS question, not total
                            correct_answers: QuizState.correctAnswers
                        }
                    }));

                    // Don't send duplicate score_update - already sent in submit_answer
                }

                // Wait for server next_question event - no client-side advancement
                console.log('[Quiz] Answer submitted, waiting for server next_question event');
            } else {
                setTimeout(() => {
                    QuizState.currentQuestionIndex++;
                    displayQuestion();
                }, 2000);
            }
        }

        function updateScoreDisplay() {
            const scoreEl = document.getElementById('currentScore');
            if (scoreEl) scoreEl.textContent = QuizState.score;

            // Update score badge in header
            const scoreBadge = document.getElementById('score');
            if (scoreBadge) {
                scoreBadge.textContent = `${QuizState.correctAnswers}/${QuizState.questions.length}`;
            }

            const totalAnswered = QuizState.currentQuestionIndex;
            if (totalAnswered > 0) {
                const accuracy = (QuizState.correctAnswers / totalAnswered * 100).toFixed(0);
                const footerAccuracyEl = document.getElementById('footerAccuracy');
                if (footerAccuracyEl) footerAccuracyEl.textContent = accuracy + '%';
            }
            
            const gameData = localStorage.getItem('multiplayerGame');
            if (gameData && JSON.parse(gameData).isMultiplayer) {
                MultiplayerState.updateScoreboard();
                MultiplayerState.sendScoreUpdate();
            }
        }

        function updateStreakDisplay() {
            const streakEl = document.getElementById('streakDisplay');
            if (streakEl) streakEl.textContent = `${QuizState.currentStreak}üî•`;
        }

        function showResults() {
            QuizState.clearTimer();

            // End game session
            fetch('/api/game/end', { method: 'POST' }).catch(err => console.error('Failed to end game session:', err));

            const modal = document.getElementById('resultsModal');
            modal.classList.add('show');

            const accuracy = QuizState.questions.length > 0 ?
                (QuizState.correctAnswers / QuizState.questions.length * 100).toFixed(1) : 0;

            document.getElementById('finalScore').textContent = QuizState.score;
            document.getElementById('finalAccuracy').textContent = `${accuracy}%`;
            document.getElementById('correctCount').textContent =
                `${QuizState.correctAnswers}/${QuizState.questions.length}`;
            document.getElementById('bestStreak').textContent = QuizState.bestStreakValue;
        }

        let confirmModalTimerInterval = null;

        function confirmExit(event) {
            event.preventDefault();
            
            if (QuizState.currentQuestionIndex === 0 && QuizState.score === 0) {
                window.location.href = '/';
                return;
            }
            
            const modal = document.getElementById('confirmModal');
            modal.classList.add('show');
            
            updateConfirmModalTimer();
            confirmModalTimerInterval = setInterval(updateConfirmModalTimer, 100);
        }

        function updateConfirmModalTimer() {
            const timerValueEl = document.getElementById('confirmTimerValue');
            if (timerValueEl) {
                timerValueEl.textContent = QuizState.timeRemaining;
                
                if (QuizState.timeRemaining <= 5) {
                    timerValueEl.style.color = '#f44336';
                } else if (QuizState.timeRemaining <= 10) {
                    timerValueEl.style.color = '#ff9800';
                } else {
                    timerValueEl.style.color = '#4CAF50';
                }
            }
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            if (confirmModalTimerInterval) {
                clearInterval(confirmModalTimerInterval);
                confirmModalTimerInterval = null;
            }
        }

        function showOpponentQuitModal() {
            const modal = document.getElementById('opponentQuitModal');
            if (modal) modal.classList.add('show');
        }

        function exitToSettings() {
            const gameData = localStorage.getItem('multiplayerGame');
            if (gameData && JSON.parse(gameData).isMultiplayer) {
                notifyOpponentQuit();
            }
            QuizState.clearTimer();
            if (confirmModalTimerInterval) {
                clearInterval(confirmModalTimerInterval);
                confirmModalTimerInterval = null;
            }
            window.location.href = '/settings.html';
        }

        function exitToHome() {
            const gameData = localStorage.getItem('multiplayerGame');
            if (gameData && JSON.parse(gameData).isMultiplayer) {
                notifyOpponentQuit();
            }
            QuizState.clearTimer();
            if (confirmModalTimerInterval) {
                clearInterval(confirmModalTimerInterval);
                confirmModalTimerInterval = null;
            }
            window.location.href = '/';
        }

        function notifyOpponentQuit() {
            if (MultiplayerState.ws && MultiplayerState.ws.readyState === WebSocket.OPEN) {
                const game = JSON.parse(localStorage.getItem('multiplayerGame') || '{}');
                const roomCode = MultiplayerState.roomCode || game.room_code || game.roomCode || null;

                // Modern payload
                MultiplayerState.ws.send(JSON.stringify({
                    type: 'player_quit',
                    payload: { room_code: roomCode }
                }));
                // Legacy
                MultiplayerState.ws.send(JSON.stringify({
                    type: 'player_quit',
                    roomCode: roomCode
                }));
            }
        }

        window.addEventListener('beforeunload', () => {
            // End game session when user closes tab
            const token = localStorage.getItem('token');
            if (token) {
                navigator.sendBeacon('/api/game/end', new Blob([JSON.stringify({})], {
                    type: 'application/json'
                }));
            }

            const gameData = localStorage.getItem('multiplayerGame');
            if (gameData && JSON.parse(gameData).isMultiplayer) {
                notifyOpponentQuit();
            }
        });

        async function loadPreferencesFromDatabase() {
            const token = localStorage.getItem('token');
            if (!token) {
                // Guest user - use localStorage only
                return;
            }

            try {
                const response = await fetch('/api/auth/preferences', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Update localStorage with database values
                        localStorage.setItem('selectedThemes', JSON.stringify(data.selected_themes || []));
                        localStorage.setItem('quizSettings', JSON.stringify({
                            timeLimit: data.quiz_time_limit || 10,
                            questionCount: data.quiz_question_count || 10
                        }));

                        console.log('Loaded preferences from database:', data);
                    }
                }
            } catch (error) {
                console.warn('Failed to load preferences from database, using localStorage:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // ========================================
            // ENTRY POINT VALIDATION
            // ========================================
            // Enforce proper entry points: Quick Start OR Multiplayer modal ONLY
            // Do not allow direct quiz.html access without proper setup

            const multiplayerGame = localStorage.getItem('multiplayerGame');
            const quizSettings = localStorage.getItem('quizSettings');
            const selectedThemes = localStorage.getItem('selectedThemes');

            let isValidEntry = false;

            // Check if this is a multiplayer game (valid entry)
            if (multiplayerGame) {
                try {
                    const game = JSON.parse(multiplayerGame);
                    console.log('üîç Checking multiplayer game data:', game);

                    // For multiplayer, we just need isMultiplayer flag
                    // gameId is optional - can be any of these variations or even missing
                    if (game.isMultiplayer) {
                        isValidEntry = true;
                        const gameId = game.gameId || game.game_id || 'multiplayer-session';
                        console.log('‚úÖ Valid entry: Multiplayer game', gameId);
                    } else {
                        console.warn('‚ö†Ô∏è Missing isMultiplayer flag');
                    }
                } catch (e) {
                    console.error('Invalid multiplayer game data:', e);
                }
            }

            // Check if this is a Quick Start game (valid entry)
            if (!isValidEntry && quizSettings && selectedThemes) {
                try {
                    const settings = JSON.parse(quizSettings);
                    const themes = JSON.parse(selectedThemes);

                    if (settings.timeLimit && settings.questionCount && Array.isArray(themes) && themes.length > 0) {
                        isValidEntry = true;
                        console.log('‚úÖ Valid entry: Quick Start with settings');
                    }
                } catch (e) {
                    console.error('Invalid quiz settings or themes');
                }
            }

            // Redirect if invalid entry
            if (!isValidEntry) {
                console.warn('‚ö†Ô∏è Invalid entry point detected - redirecting to home page');
                alert('Please start a quiz from the home page using Quick Start or Multiplayer.');
                window.location.href = '/';
                return;
            }

            // Check if this is a multiplayer game
            let isMultiplayerGame = false;
            if (multiplayerGame) {
                try {
                    const game = JSON.parse(multiplayerGame);
                    isMultiplayerGame = game.isMultiplayer === true;
                } catch (e) {
                    console.error('Error parsing multiplayer game:', e);
                }
            }

            // Skip active game session check for multiplayer (it has its own session management)
            if (!isMultiplayerGame) {
                console.log('üéÆ Single player mode - checking for active game session...');

                // üßπ Clean up any stale multiplayer data in single player mode
                console.log('üßπ Cleaning up stale multiplayer data...');
                localStorage.removeItem('multiplayerGame');
                localStorage.removeItem('currentRoomCode');
                localStorage.removeItem('currentGameURL');
                console.log('‚úÖ Stale multiplayer data cleared');
                try {
                    const checkResponse = await fetch('/api/game/check-active');
                    if (checkResponse.ok) {
                        const checkData = await checkResponse.json();
                        if (checkData.success && checkData.hasActive) {
                            // User already has an active game
                            const proceed = confirm('You are already playing a game in another tab. Do you want to continue that game here?\n\nClick OK to resume, or Cancel to go back home.');
                            if (!proceed) {
                                window.location.href = '/';
                                return;
                            }
                        }
                    }

                    // Start new game session
                    const startResponse = await fetch('/api/game/start', { method: 'POST' });
                    if (startResponse.status === 409) {
                        // Already playing
                        alert('You are already playing a game. Please finish that game first.');
                        window.location.href = '/';
                        return;
                    }
                } catch (error) {
                    console.error('Failed to check game session:', error);
                }
            } else {
                console.log('üåê Multiplayer mode - skipping active game session check');
            }

            await loadPreferencesFromDatabase(); // Load from DB first

            const scoreboard = document.getElementById('scoreboard');
            const opponentCard = document.getElementById('opponentPlayerScore');

            const gameDataStr = localStorage.getItem('multiplayerGame');
            if (gameDataStr) {
                const game = JSON.parse(gameDataStr);

                if (game.isMultiplayer) {
                    if (scoreboard) scoreboard.classList.add('show');
                    if (opponentCard) opponentCard.style.display = '';

                    MultiplayerState.roomCode = game.room_code || game.roomCode || null;

                    const hasReconnectIds = !!((game.gameId || game.game_id) && (game.participantId || game.participant_id));
                    const hasRoom = !!(game.room_code || game.roomCode);
                    if (!hasReconnectIds && !hasRoom) {
                        console.warn('[Quiz] Missing multiplayer identifiers');
                    }
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    // game is already defined above, no need to redefine
                    let playerId = localStorage.getItem('playerId');

                    // Generate player ID if not exists or is null/undefined
                    if (!playerId || playerId === 'null' || playerId === 'undefined') {
                        playerId = 'player_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                        localStorage.setItem('playerId', playerId);
                        console.log('[Quiz] Generated new player ID:', playerId);
                    }

                    const username = localStorage.getItem('playerName') || 'Player';

                    // Store in MultiplayerState for later use
                    MultiplayerState.playerId = playerId;
                    MultiplayerState.roomCode = game.room_code || game.roomCode || null;

                    // ‚úÖ Origin-aware WebSocket URL (port 4000 for localhost dev, same host for production)
                    const wsHost = window.location.hostname === 'localhost' ? 'localhost:4000' : window.location.host;
                    const wsUrl = `${protocol}//${wsHost}/ws?player_id=${playerId}&username=${encodeURIComponent(username)}`;
                    console.log('[Quiz] Connecting with player_id:', playerId, 'room:', MultiplayerState.roomCode);
                    MultiplayerState.ws = new WebSocket(wsUrl);
                    MultiplayerState.reconnectAttempts = 0;

                    MultiplayerState.ws.onopen = () => {
                        console.log('[Quiz] ‚úÖ WebSocket connected');
                        MultiplayerState.reconnectAttempts = 0;
                        MultiplayerState.reconnectDelay = 1000; // Reset delay

                        // Start heartbeat
                        MultiplayerState.startHeartbeat();

                        const gameId = game.gameId || game.game_id;

                        if (gameId) {
                            // Send reconnect message to rejoin the game room
                            console.log('üîÑ Reconnecting to game:', gameId);
                            MultiplayerState.ws.send(JSON.stringify({
                                type: 'reconnect',
                                payload: { game_id: gameId }
                            }));
                        } else {
                            const rc = MultiplayerState.roomCode;
                            if (rc) {
                                console.log('üö™ Joining room:', rc);
                                MultiplayerState.ws.send(JSON.stringify({
                                    type: 'join_room',
                                    payload: { room_code: rc }
                                }));
                            }
                        }
                    };

                    MultiplayerState.ws.onerror = (error) => {
                        console.error('[Quiz] ‚ùå WebSocket error:', error);
                    };

                    MultiplayerState.ws.onclose = (event) => {
                        console.log('[Quiz] WebSocket closed:', event.code, event.reason);

                        // Stop heartbeat
                        MultiplayerState.stopHeartbeat();

                        // Don't reconnect if game completed or intentional close
                        if (event.code === 1000) {
                            console.log('[Quiz] Normal closure, not reconnecting');
                            return;
                        }

                        // Attempt reconnection with exponential backoff
                        MultiplayerState.attemptReconnect();
                    };

                    MultiplayerState.ws.onmessage = (event) => {
                        try {
                            const msg = JSON.parse(event.data);

                            // Handle pong response for heartbeat
                            if (msg.type === 'pong') {
                                MultiplayerState.lastPongTime = Date.now();
                                console.log('[Quiz] ‚ù§Ô∏è Pong received');
                                return;
                            }

                            // Process message with sequence number ordering (unless it's a buffered replay)
                            if (!msg._skipOrdering) {
                                const orderedMsg = MultiplayerState.processMessage(msg);
                                if (!orderedMsg) {
                                    // Message was buffered or dropped, don't process yet
                                    return;
                                }
                                // Continue processing the ordered message
                            }

                            const payload = typeof msg.payload === 'string'
                                ? (msg.payload ? JSON.parse(msg.payload) : {})
                                : (msg.payload || {});

                            const pick = (a, b) => (a !== undefined ? a : b);

                            switch (msg.type) {
                                // PURE score updates - scoreboard only, NO question advancement
                                case 'score_update':
                                case 'opponent_update': {
                                    const score = Number(pick(payload.score, msg.score)) || 0;
                                    const correct = Number(
                                        pick(payload.correct_answers, pick(payload.correctAnswers, msg.correctAnswers))
                                    ) || 0;
                                    MultiplayerState.updateOpponentScore(score, correct);
                                    // NO auto-advance - only update scoreboard
                                    break;
                                }

                                // Answer submission - update scores only
                                case 'answer_submitted':
                                case 'opponent_answered': {
                                    // Update score if provided
                                    const score = Number(pick(payload.score, msg.score));
                                    const correct = Number(
                                        pick(payload.correct_answers, pick(payload.correctAnswers, msg.correctAnswers))
                                    );
                                    if (!Number.isNaN(score) || !Number.isNaN(correct)) {
                                        MultiplayerState.updateOpponentScore(
                                            Number.isNaN(score) ? MultiplayerState.opponentScore : score,
                                            Number.isNaN(correct) ? MultiplayerState.opponentCorrectAnswers : correct
                                        );
                                    }

                                    // Mark opponent as answered but don't advance
                                    MultiplayerState.opponentAnswered = true;
                                    console.log('[Quiz] Opponent answered, waiting for server next_question event');
                                    break;
                                }

                                // Server-driven question advancement (supports N players)
                                case 'next_question': {
                                    const nextIndex = Number(pick(payload.question_index, msg.question_index));
                                    console.log('[Quiz] Server advancing to question', nextIndex);

                                    QuizState.clearTimer();
                                    setTimeout(() => {
                                        MultiplayerState.reset();
                                        QuizState.currentQuestionIndex = nextIndex;
                                        displayQuestion();
                                    }, 1000);
                                    break;
                                }

                                // Game completion
                                case 'game_complete': {
                                    console.log('[Quiz] üèÅ Game complete event received from server');
                                    QuizState.clearTimer();

                                    // Close WebSocket properly
                                    if (MultiplayerState.ws) {
                                        MultiplayerState.ws.close(1000, 'Game completed');
                                    }

                                    // Let the quiz complete naturally
                                    break;
                                }

                                // Reconnection confirmation with game state
                                case 'reconnected': {
                                    console.log('[Quiz] Reconnected to game:', payload);

                                    // Validate reconnection success
                                    if (!payload.success) {
                                        console.error('[Quiz] ‚ùå Reconnection failed:', payload.error);
                                        alert('Failed to reconnect to game. Please return to main menu.');
                                        window.location.href = '/';
                                        return;
                                    }

                                    console.log('[Quiz] ‚úÖ Reconnection successful');

                                    // Update sequence tracking to prevent replaying stale messages
                                    if (payload.current_seq !== undefined) {
                                        MultiplayerState.lastSeq = payload.current_seq;
                                        console.log('[Quiz] Synced message sequence to:', payload.current_seq);
                                    }

                                    // Restore all player scores
                                    if (payload.player_scores) {
                                        console.log('[Quiz] Received player scores:', payload.player_scores);

                                        // Restore own score
                                        if (MultiplayerState.playerId) {
                                            const myScore = payload.player_scores[MultiplayerState.playerId];
                                            if (myScore !== undefined) {
                                                QuizState.score = myScore;
                                                console.log('[Quiz] Restored own score:', myScore);
                                                updateScoreDisplay();
                                            }
                                        }

                                        // Restore opponent scores
                                        for (const [playerId, score] of Object.entries(payload.player_scores)) {
                                            if (playerId !== MultiplayerState.playerId) {
                                                MultiplayerState.updateOpponentScore(score, 0);
                                                console.log('[Quiz] Restored opponent score:', playerId, score);
                                            }
                                        }
                                    }

                                    // Sync who has answered current question
                                    if (payload.players_answered) {
                                        const hasMyPlayerAnswered = payload.players_answered[MultiplayerState.playerId];
                                        MultiplayerState.currentPlayerAnswered = !!hasMyPlayerAnswered;
                                        console.log('[Quiz] Current player answered status:', MultiplayerState.currentPlayerAnswered);
                                    }

                                    // Validate game state before syncing
                                    if (payload.game_started && payload.current_question !== undefined) {
                                        const qIndex = payload.current_question;
                                        const qCount = payload.question_count || QuizState.questions.length;

                                        // Validate question index is in valid range
                                        if (qIndex >= 0 && qIndex < qCount) {
                                            console.log('[Quiz] Syncing to question', qIndex);
                                            // Server will send question_sync next
                                        } else {
                                            console.warn('[Quiz] Invalid question index from server:', qIndex);
                                        }
                                    }
                                    break;
                                }

                                // Question sync after reconnection
                                case 'question_sync': {
                                    const syncIndex = Number(pick(payload.question_index, msg.question_index));
                                    console.log('[Quiz] Syncing to question', syncIndex);
                                    QuizState.currentQuestionIndex = syncIndex;
                                    displayQuestion();
                                    break;
                                }

                                case 'player_quit':
                                case 'opponent_left':
                                    QuizState.clearTimer();
                                    showOpponentQuitModal();
                                    break;

                                default:
                                    break;
                            }
                        } catch (e) {
                            console.error('Error parsing WebSocket message:', e);
                        }
                    };

                    if (game.opponentName) {
                        MultiplayerState.opponentName = game.opponentName;
                        const opponentNameEl = document.getElementById('opponentPlayerName');
                        const opponentAvatarEl = document.getElementById('opponentPlayerAvatar');
                        if (opponentNameEl) opponentNameEl.textContent = '@' + game.opponentName;
                        if (opponentAvatarEl) {
                            opponentAvatarEl.textContent = game.opponentName.charAt(0).toUpperCase();
                        }
                    }

                    const currentUser = JSON.parse(localStorage.getItem('user') || '{}');
                    if (currentUser.username) {
                        const currentNameEl = document.getElementById('currentPlayerName');
                        const currentAvatarEl = document.getElementById('currentPlayerAvatar');
                        if (currentNameEl) currentNameEl.textContent = '@' + currentUser.username;
                        if (currentAvatarEl) {
                            currentAvatarEl.textContent = currentUser.username.charAt(0).toUpperCase();
                        }
                    }
                } else {
                    if (scoreboard) scoreboard.classList.remove('show');
                    if (opponentCard) opponentCard.style.display = 'none';
                }
            } else {
                if (scoreboard) scoreboard.classList.remove('show');
                if (opponentCard) opponentCard.style.display = 'none';
            }

            startQuiz();
        });

        function openAboutModal() {
            const modal = document.getElementById('aboutModal');
            if (modal) modal.classList.add('show');
        }

        function closeAboutModal() {
            const modal = document.getElementById('aboutModal');
            if (modal) modal.classList.remove('show');
        }
    </script>
</body>
</html>